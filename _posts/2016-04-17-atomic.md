---
layout: post
title: AtomicInteger 
tags: java concurrency atmoic
categories: lisp
---
## AtomicXXX
在java.concurrent.atomic包中，有很多基本数据的atomic类，以其中的AtomicInteger为例，分析一下他们的实现原理。
AtmoicInteger是Integer的原子类型，提供了compareAndSet等操作接口。在AtmoicInteger类的私有变量如下：

```java
private static final Unsafe unsafe = Unsafe.getUnsafe();
private static final long valueOffset;

static {
	try {
		valueOffset = unsafe.objectFieldOffset
			(AtomicInteger.class.getDeclaredField("value"));
	} catch (Exception ex) { throw new Error(ex); }
}

private volatile int value;

```
在上述代码中，最重要的就是Unsafe，Unsafe是sun公司的未开源包中的类，能够进行很多的geek操作，可以对内存进行直接的操作，在AtomicInteger中，Unsafe类直接提供了compareAndSet操作支持。

```java
public final boolean compareAndSet(int expect, int update) {
	return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```
其他的操作，如weakCompareAndSet、getAndIncrement等都是直接调用unsafe接口实现的。
可以看到，在进行compareAndSet操作的时候，为了实现数据的一致性，用于保存value的值的类型是volatile。这样当数据有更改的时候，其他线程会立即看到更新。通过这种方式，实现了对数据的原子操作。
Java中，AtomicBoolean、AtomicInteger、AtomicLong都是上面这种思路来实现的。
