---
layout: post
title: kmp algorithm
tags: algorithm
categories: algorithm
---
### KMP 算法
&emsp;&emsp;KMP算法是一种线性匹配算法，能够在O(m+n)的时间内判别text中是否含有pattern。KMP算法虽然实现比较简单，但是理解起来是比较困难的。要理解KMP算法的实现原理，首先需要看一下暴力算法是如何实现匹配的。对于pattern字符串"ABCDABD"，如果匹配到D时，text与pattern不相等<br>
<p align="center">
![runtime][png1]
</p>
<br> 那么，下一次又将需要从头开始匹配 <br>
<p align="center">
![runtime][png2]
</p>
<br>
&emsp;&emsp;KMP算法的精髓在于能够利用已有的匹配信息，这样当下一次匹配的时候，就不需要从头开始进行匹配了。这里需要提到两个概念，前缀和后缀，对于字符串"ABCDABD"而言，其前缀包括"A","AB","ABC","ABCD","ABCDA","ABCDAB",对应的，其后缀包括"D","BD","ABD","DABD","CDABD","BCDABD"。以字符串"ABCDABD"为例，假设目标字符串是"ABCDABXABC",显然X通不过匹配，这个时候pattern中匹配位置j对应的字符是D。下一此应该从哪里开始呢，很明显下一次应该从pattern的第三个字符开始匹配。也就是说next[j]=2（下标从0开始）。这个2又是如何得来的呢，字符D之前的字符串是ABCDAB，之所以从从C开始比较，因为已匹配的字符串中有AB了，也就是后缀与前缀相同。通过上面的分析，我们可以看到，对于pattern，下一个匹配的位置应该就是其最长前缀和后缀相等的长度。对于pattern=ABCDABD而言，next[6]=2;<br>
&emsp;&emsp;那么如何求得最长的前缀和后缀相等的串呢？对于pattern=ABCDABD，按照如下步骤,就可以获得next：<br>
``` java
int []next = new int[len(pattern)];
for (i = 1;i < len(pattern);i ++){
    int j = next[i];
    while(j != 0 && pattern[i] != pattern[j]){
        j = next[j];
    }
    next[i+1] = pattern[i] == pattern[j]?j+1:0;
}
```
&emsp;&emsp;获得了next数组之后，我们在进行匹配的时候就可以利用类似的方式执行了。<br>
``` java

int kmp(char[]pattern,char[]text){
    int p = 0;
    int []next = get_next(pattern);
    for(int i = 0;i < len(text);i ++){
        while(p != 0 ||pattern[p] != text[i]){
            p = next[p];
        }
        if(pattern[p] == text[i]){
            p ++;
        }
        if(p == len(pattern)) return i+1-len(pattern);
    }
    return -1;
}

```
<br>
&emsp;&emsp;KMP算法在理解的时候确实有些难度，可以通过各种方式来解释这个算法，比如算法这本书上面就是按照DFA的方式来解释KMP算法的，确实如此，不过在计算DFA的时候我不是很能理解，下次估计就得好好的处理了。



[png1]: {{"/kmp-1.png" | prepend: site.imgrepo }}
[png2]: {{"/kmp-1.png" | prepend: site.imgrepo }}